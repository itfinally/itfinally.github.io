# 消息系统的幂等设计及其对接注意事项

## 消息系统的幂等问题

在消息发送方面, 有如下三种观点:

 - 最多发送成功一次, 丢失不管
 - 最少发送成功一次, 可能重现重复
 - 恰好成功一次, 既不会出现丢失也不会重复


第三种情况是最难达成的, 因为中间总会因为系统宕机, 连接中断, 网络不稳定等多种原因, 导致消息最终不可达, 为了解决这种消息丢失的情况, 那么再发送一次是比较稳妥的方式, 但发送方本身是没办法知道上次发送的消息到底是真的不成功, 还是因为网络原因出现阻滞但最终到达了消费方. 
 
因此幂等功能是消息系统设计的一项重要课题, 如何实现消息最少一次且仅有一次的消费是一项看似不可能解决的问题. 在设计消息系统时, 需要开发者对其开发的消息系统作出立场.
 
由于最多发送一次这种方式存在消息丢失的可能, 而且消息丢失比较难处理, 因此采取最少发送一次的方式. 另外消息系统本身会做一部分的幂等处理, 但对接方也需要将业务本身设计为幂等.
 
## 何为幂等

幂等, 是数学的概念, 大意是 "存在一个 y = f(x) 的函数, x 不变时, 无论调用多少次 f(x) 函数, 永远得出 y 的结果". 也就是说, 处理流程本身是无状态的, 且处理时不会基于上次的状态作出决策.

这句话怎么理解? 举个例子:

设 x = 1, 那么 f(x) = x + 1, 这里 f(x) 是幂等的, 因为只要 x 不变, y 永远只是 x + 1 的结果.

那现在存在这么一个类:

```java
public class NonIdempotent {
  public static int totalIncrement = 0;
  
  public static int incrementAndGet( int increment ) {
    return ( totalIncrement += increment );
  }
}
```

设 x = 1, totalIncrement = 0, 那么:
 
 - increnetAndGet( 1 ) -> 1
 - increnetAndGet( 1 ) -> 2
 - increnetAndGet( 1 ) -> 3

这里看似简单而结果也很明了的函数, 并非是幂等函数, 因为每次调用后, 函数本身的状态出现了变化, 而函数本身的流程也依赖于内部的上一次状态. 它破坏了幂等最基础的两个原则, 即 "函数是无状态的" 以及 "函数运算不依赖上一次状态".

假如依然觉得比较难理解, 举个最贴近工作的例子.

数据库的 insert 语句本身就不是幂等的, 每一次调用执行 insert 都会插入一条数据, 即使数据本身是一模一样.

但假设数据上某一字段存在 unique 语义, 那么针对该类数据的 insert 语句我们可以说是幂等的, 因为不可能插入一模一样的两条数据.

比如 select 语句, 是天然幂等语句, 在 where 语句的条件不变的情况下, 无论执行多少次所得出的数据集都是一模一样的.

总的来说, 最简单可以总结为, <strong>输入不变的情况下, 通过相同的处理后得出的结果必然是不变的.</strong>

## 业务幂等

上面唠唠叨叨说了那么多, 其实都是为了说明白业务如何做到幂等.

假设订单系统一共有三个 docker 实例服务.

由于消息系统本身也需要考虑性能, <strong>在`同一种类的多个服务实例`在消费某一条消息时, 不可能与同类去协商检查这条消息在这个种类的服务内到底有没有消费过, 只能设计为在某段时间内`自己这个服务实例`到底有没有消费过.</strong>

那么在这种情况下, 基于 "最少一次成功" 的消息发送策略, 有可能在消息中间件内存在两条一模一样的消息, 并且根据中间件的派送策略, <strong>这种消息会发送到同种类的不同实例上</strong>, 那么这里就需要业务方的流程本身是幂等的.

那么如何做到流程幂 ?

首先业务流程涉及的类对于流程本身必须是无状态的, 对于类的状态根据其作用可以划分很多种, 如为了线程安全而设计的状态变量, 为了记录业务流程进度设计的状态变量等.

另外需要将基于上一次状态进行运算的流程修改为记账模式. 简单来说, 就是将 "x++" 的自增模式改为一条条 "+ 1" 的记账模式.

上面这句话会比较生涩, 这里以微博的点赞功能作为说明. 

微博大家都玩过, 点赞只不过是一个很简单的功能, 但是如何做到 "用户点一次赞时系统只会给对应的微博信息加一个赞" 这个目的呢 ?

每条微博数据上都有一个 awesome_count 字段, 每次点赞都直接 + 1 吗？

这个设计可以说是最简单最实用的, 但是在实践中总会有点问题, 比如用户连续点了好几次赞, 比如消息系统重复投递信息导致的重复点赞, 应该如何杜绝? 毕竟每个用户对同一条微博只能连续赞一次, 也只能连续取消一次赞, 这才是正确的业务目的.

那么如果改成记账模式那又如何？

当每个用户都有一个唯一 id, 我们建立一个 awesome_blog_list , 并且设定 ( user_id, blog_id ) 为联合唯一键, 那么这个流程设计便从`有状态的自增` 变为 `无状态的记账`. 无论用户有意或无意, 在数据上都只会存在`单个用户对单条微博只能连续点赞一次`的情况, 同时还赠送了用户行为收集的功能.

( 对于取消赞由重新点赞这种行为的辩论, 请注意上文的 `只能连续点赞/取消点赞` 一词 )

而改为这种设计后, 在真实数据上我们做到了严格的幂等控制, 而性能上虽然有所减弱, 但弥补的手段较多, 并且相对容易, 如计算微博的点赞数后缓存在 redis 等, 给用户看到的仅仅是个粗略的统计, 实际上用户并不关心这种粗略的中间数字, 只需要保证最终结果是正确的即可.

一定程度来说, 也是一种最终一致性的实现.




